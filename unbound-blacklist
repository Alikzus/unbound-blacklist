#!/usr/bin/env perl
#
# unbound-blacklist: Create an include file for unbound with domains to block
#
# Copyright (c) 2014-2016, Joel A. Nilsson <joel@alikzus.se>
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
# INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
# LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
# OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
# PERFORMANCE OF THIS SOFTWARE.
#

use 5.20.2;

use strict;
use warnings;

use Carp;
use English '-no_match_vars';
use Getopt::Long::Descriptive;
use Readonly;

################################################################################
# PARAMETERS
################################################################################

# The same sources as AdAway for Android, 2016-04-05
Readonly my @SOURCES => (
    'http://hosts-file.net/ad_servers.txt',
    'http://pgl.yoyo.org/adservers/serverlist.php?hostformat=hosts&showintro=0&mimetype=plaintext',
    'http://winhelp2002.mvps.org/hosts.txt',
    'https://adaway.org/hosts.txt',
);

# TODO Replace with getopts
my $BLACKLIST = '/var/unbound/db/blacklist';
#my $BLACKLIST = '/tmp/blacklist.txt';

################################################################################
# CONSTANT DEFINITIONS
################################################################################

Readonly my $PROGRAM_NAME => 'unbound-blacklist';

Readonly my $EMPTY_STRING => '';

Readonly my $CARRIAGE_RETURN => qr/\r$/;
Readonly my $COMMENT         => qr/\s+#.*/;
Readonly my $IP_ADDRESS      => qr/^\d{1,3}\.0\.0\.\d\s+/;

################################################################################
# MAIN
################################################################################

my @list;

for my $source (@SOURCES) {
    open my $fetch_fh,'-|:encoding(ascii)',"/usr/bin/ftp -o - \'$source\'"
        or carp $OS_ERROR;

    while ( my $line = <$fetch_fh> ) {
        push @list, $line;
    }

    close $fetch_fh or croak $OS_ERROR;
}

my %domains;

parse_list();

system("/bin/mv", "$BLACKLIST", "$BLACKLIST.bak");

open my $blacklist_fh, '>:encoding(ascii)', "$BLACKLIST" or carp $OS_ERROR;
print $blacklist_fh generate_content();
close $blacklist_fh or croak $OS_ERROR;

if ( system("/usr/sbin/unbound-checkconf") ) {
    system( "/bin/mv", "$BLACKLIST", "$BLACKLIST.broken" );
    system( "/bin/mv", "$BLACKLIST.bak", "$BLACKLIST" );
    say STDERR "$PROGRAM_NAME: Invalid unbound configuration";
}
else {
    system( "/etc/rc.d/unbound", "reload" );
    say STDOUT "$PROGRAM_NAME: Done";
}

exit;

################################################################################
# SUBROUTINES
################################################################################

sub parse_list
{
    for my $line (@list) {
        chomp $line;
        $line =~ s/$CARRIAGE_RETURN/$EMPTY_STRING/xms;

        my $domain;

        # TODO Make more tidy
        if ( $line =~ s/$IP_ADDRESS/$EMPTY_STRING/xms ) {
            ( $domain = $line ) =~ s/$COMMENT/$EMPTY_STRING/xms;
            $domain =~ s/\.$/$EMPTY_STRING/xms; # TODO qr/
            $domain = lc $domain;
        }

        if ( $domain && ( $domain ne 'localhost' ) && ( !$domains{$domain} ) ) {
            $domains{$domain} = 1;
        }
    }
}

#-------------------------------------------------------------------------------

sub generate_content
{
    my $timestamp = get_timestamp();

    my $content = qq{# Generated with $PROGRAM_NAME, $timestamp\n};

    for my $domain ( keys %domains ) {
        $content .= qq{local-zone: "$domain" static\n};
    }

    return $content;
}

#-------------------------------------------------------------------------------

sub get_timestamp
{
    my ( $sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst ) = localtime();

    $mon  += 1;
    $year += 1900;

    $mon  = sprintf("%02u", $mon);
    $mday = sprintf("%02u", $mday);
    $hour = sprintf("%02u", $hour);
    $min  = sprintf("%02u", $min);
    $sec  = sprintf("%02u", $sec );

    return "${year}-${mon}-${mday}T${hour}:${min}:${sec}";
}

################################################################################
# Last updated: 2016-04-06 18:10:31 CEST
