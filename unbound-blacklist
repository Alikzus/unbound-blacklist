#!/usr/bin/env perl
#
# unbound-blacklist: Create an include file for unbound with domains to block
#
# Usage: unbound-blacklist [-dh] [-f file]
#
# Copyright (c) 2014-2016, Joel A. Nilsson <joel@alikzus.se>
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
# INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
# LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
# OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
# PERFORMANCE OF THIS SOFTWARE.
#

use 5.20.3;

use strict;
use warnings;

use Carp;
use English '-no_match_vars';
use Getopt::Long::Descriptive;
use Readonly;
use POSIX 'strftime';

################################################################################
# PARAMETERS
################################################################################

# The same sources as AdAway for Android, 2016-04-05
Readonly my @SOURCES => (
    'http://hosts-file.net/ad_servers.txt',
    'http://pgl.yoyo.org/adservers/serverlist.php?hostformat=hosts&showintro=0&mimetype=plaintext',
    'http://winhelp2002.mvps.org/hosts.txt',
    'https://adaway.org/hosts.txt',
);

################################################################################
# CONSTANT DEFINITIONS
################################################################################

Readonly my $AUTHOR_NAME => 'Joel A. Nilsson <joel@alikzus.se>';
Readonly my $SCRIPT_NAME => 'unbound-blacklist';

Readonly my $EMPTY_STRING => '';

Readonly my $RE_FQDN_DOT    => qr/\.$/;
Readonly my $RE_COMMENT     => qr/\s+#.*/;
Readonly my $RE_IP_ADDRESS  => qr/^\d{1,3}\.0\.0\.\d\s+/;
Readonly my $RE_LINE_ENDING => qr/\r?\n$/;

################################################################################
# OPTIONS AND ARGUMENTS
################################################################################

my ( $options, $usage ) = describe_options(
  "$SCRIPT_NAME %o <some-arg>",
  [ 'file|f=s',  "the output file" ],
  [ 'white|w=s', "optional whitelist file" ],
  [ 'debug|d',   "debug mode" ],
  [ 'verbose|v', "verbose mode" ],
  [ 'help|h',    "print this usage message and exit" ],
);

if ( $options->help ) {
    print $usage->text;
    exit;
}

my $blacklist_file;
if ( $options->file ) {
    $blacklist_file = $options->file;
}
elsif ( $options->debug ) {
    $blacklist_file = '/tmp/unbound_blacklist';
}
else {
    $blacklist_file = '/var/unbound/db/blacklist';
}

my $fetch_options = '-';
if ( $options->verbose ) {
    $fetch_options .= 'o';
}
else {
    $fetch_options .= 'Vo';
}

################################################################################
# MAIN
################################################################################

# Housekeeping
if ( -f "$blacklist_file.broken" ) {
    system( "/bin/rm", "$blacklist_file.broken" );
}

my %white_domains;
if ( $options->white ) {
    open my $whitelist_fh, '<:encoding(ascii)', $options->white
        or carp $OS_ERROR;
    while ( my $line = <$whitelist_fh> ) {
        my $domain;
        if ( $line !~ m/$RE_COMMENT/ ) {
            $line =~ s/$RE_LINE_ENDING/$EMPTY_STRING/xms;
            ( $domain = $line ) =~ s/$RE_COMMENT/$EMPTY_STRING/xms;
            $domain =~ s/$RE_FQDN_DOT/$EMPTY_STRING/xms;
            $domain = lc $domain;
        if ( $domain ) {
            $white_domains{$domain}++;
        }
    }
    close $whitelist_fh or croak $OS_ERROR;
}

my %black_domains;
for my $source (@SOURCES) {
    open my $fetch_fh, '-|:encoding(ascii)',
        "/usr/bin/ftp $fetch_options - \'$source\'"
        or carp $OS_ERROR;
    while ( my $line = <$fetch_fh> ) {
        my $domain;
        if ( $line =~ s/$RE_IP_ADDRESS/$EMPTY_STRING/xms ) {
            $line =~ s/$RE_LINE_ENDING/$EMPTY_STRING/xms;
            ( $domain = $line ) =~ s/$RE_COMMENT/$EMPTY_STRING/xms;
            $domain =~ s/$RE_FQDN_DOT/$EMPTY_STRING/xms;
            $domain = lc $domain;
        }
        if ( $domain && ( $domain ne 'localhost' ) 
            && ( !$white_domains{$domain} ) ) {
            $black_domains{$domain}++;
        }
    }
    close $fetch_fh or croak $OS_ERROR;
}

my $timestamp = strftime( "%FT%T", localtime() );
my $content = qq{# Generated with $SCRIPT_NAME by $AUTHOR_NAME, $timestamp\n};

for my $domain ( keys %black_domains ) {
    $content .= qq{local-zone: "$domain" static\n};
}

# Fallback
if ( !$options->debug && ( -f $blacklist_file ) ) {
    system("/bin/mv", "$blacklist_file", "$blacklist_file.backup");
}

open my $blacklist_fh, '>:encoding(ascii)', "$blacklist_file" or carp $OS_ERROR;
print $blacklist_fh $content;
close $blacklist_fh or croak $OS_ERROR;

# Premature exit if debug mode
if ( $options->debug ) {
    say STDOUT "$SCRIPT_NAME: DEBUG Done";
    exit;
}

# Test the configuration and exit on error
if ( system("/usr/sbin/unbound-checkconf") ) {
    system( "/bin/mv", "$blacklist_file", "$blacklist_file.broken" );
    system( "/bin/mv", "$blacklist_file.backup", "$blacklist_file" );
    say STDERR "$SCRIPT_NAME: Invalid unbound configuration";
    exit 1;
}

# Housekeeping
if ( -f "$blacklist_file.backup" ) {
    system( "/bin/rm", "$blacklist_file.backup" );
}

system( "/etc/rc.d/unbound", "reload" );
say STDOUT "$SCRIPT_NAME: Done";
exit;

################################################################################
# Last Changed: 2017-01-14 14:13:30 CET
